- 1、运行结果为“我只能在地上奔跑”，因为虽然O类继承了B类，但是O类中重写了fly方法，并且引用类型也为O类，创
     建立对象也是指向O类，综上所述，运行结果为“我只能在地上奔跑”。这里需要注意方法重写对方法调用的影响。
- 2、运行结果为SlowPoint move parameter和Point move。因为子类SP类中重写了父类P类中的含参move方法，
     在move的重写中又调用了父类的无参move方法。所以sp.move();会打印输出两个结果。
- 3、D、在src根目录下的class文件为特例。
- 4、C、D。
        修饰符     |   本类  |   同包的类    |   子类  |   其他类   |

        public    | 可以访问 |   可以访问    | 可以访问 | 可以访问   |

        projected   可以访问    可以访问        可以访问    不能访问

        默认        可以访问     可以访问        不能访问    不能访问

        private     可以访问    不能访问        不能访问    不能访问
- 5、D。见上表
- 6、   A、错误：static修饰的成员变量属于类的数据结构，属于类的信息存放在方法区。
        B、错误：static方法不可以访问非static的成员。
        C、错误：准确的来说static成员变量属于类的属性，属于静态变量，存储于方法区，但方法区也可以算作堆
                所以说存储在堆中某种意义上也算正确。
        D、正确
    static的要点归纳：
        1、在类中，用static声明的成员变量为静态成员变量，或者叫做类属性、类变量
           1.1、它为该类的公用变量，属于类，被该类的所有实例共享，在类被在载入时被显示初始化
           1.2、可以使用"对象.类属性”来调用。不过，一般都是用“类名.类属性”
           1.3、static变量置于方法区中
        2、用static声明的方法为静态方法
           2.1、不需要对象就可以调用（类名.方法名）
           2.2、在调用该方法时，不会将对象的引用传递给他，所以在static方法中不可以访问非static的成员
           2.3、静态方法不得以任何方式引用this和super关键字
        3、静态初始化块
           3.1、如果希望加载后对整个类进行某些初始化操作，可以使用初始化块
           3.2、类第一次被载入时先执行static代码块，类多次载入时，static代码块只执行一次，static经常用来进行
                static变量的初始话
           3.3、是在类初始化时执行，不是在创建对象时执行
           3.4、静态初始化块中不能访问非static成员
- 7、
- 8、B、D（修饰符的调换不影响成员属性）